《大象 Thinking in UML》
第一部分    你需要了解
● 第一章    为什么需要UML

为什么需要UML
问：面向过程和面向对象都是一种软件技术吗？
答：事实上，技术只是人们在采用不同的方法来认识和描述这个世界时所采用的工具，它们都只是表征而不是本征。
比掌握具体的技术更重要的是掌握认识论所采用的方法和分析过程。只有掌握了方法才能自如地使用工具。

面向过程方法
面向过程方法认为我们的世界是由一个个相互关联的小系统组成的。
面向过程方法认为每个小系统都有着明确的开始和明确的结束，开始和结束之间有着严谨的因果关系。
只要我们将这个小系统中的每一个步骤和影响这个小系统走向的所有因素都分析出来，我们就能完全定义这个系统的行为。


面向对象方法
对象有着坚硬的外壳，从外部看来，除了它用来与外界交互的消息通道之外，对象内部就是一个黑匣子，什么也看不到，这称为封装；
再例如对象可以结合在一起形成新的对象，结合后的对象具有前两者特性的总和，这称为聚合；
对象可以繁育，产下的孩子将拥有父辈全部的本领，这称为继承；
每个对象都有多个外貌，在不同情况下可以展现不同的外貌，但本质只有一个，这就是接口；
而多个对象却可能长着相同的脸，但同样的这张脸背后却是不同的对象，它们有着不同的行为，这就是多态。
从宏观角度说，对象是“短视”的，它不知道也无法理解它所处的宏观环境，也不知道它的行为会对整个宏观环境造成怎样的影响。
    它只知道与它有着联系的身边的一小群伙伴，这称为依赖，
    并与小伙伴间保持着信息交流的关系，这称为耦合。
    同时对象也是“自私”的，即便在伙伴之间，每个对象也仍然顽固地保护着自己的领地，这称为类属性，
    只允许其他人通过它打开的小小窗口，这称为方法，进行交流，从不允许对方进入它的领地。
然而对象也喜欢群居，并且总是“物以类聚，人以群分”。这些群居的对象有着一些相似的性质，它们依靠这些相似的性质来组成一个部落。对象们寻找相似性质并组成部落的过程称为抽象，它们组成的部落称为类；
部落里的每个成员既有共同的性质又有自己的个性，我们只有把特有的个性赋给部落成员才能区分它们并使它们活动起来，这称为实例化。

面向对象的一个非常重要的特性：抽象层次。
以上的描述是由小及大的（或称为自底向上）的抽象过程；我们也可以反过来，由大及小（或称为自顶向下）的来抽象。
例如站在汽车的抽象层次，我们会发现汽车是由变速器、发动机、底盘等大一些的部件组成的；
如果降低一点，站在发动机的抽象层次上，我们会现发动机是由汽缸、活塞等零件组成的；
而站在活塞的抽象层次，我们还会发现活塞是由拉杆、曲轴等更小的零件组成的……只要你愿意，这种抽象层次可以一直延伸下去，直到原子，夸克……

面向对象方法与面向过程方法根本的不同，就是不再把世界看作是一个紧密关联的系统，而是看成一些相互独立的离散的小零件，这些零件依据某种规则组织起来，完成一个特定的功能。
原来，过程并非这个世界的本源，过程是由通过特定规则组织起来的一些对象“表现”出来的，原始的对象既独立于过程，也独立于组装规则。
面向对象和面向过程的这个差别导致了整个分析设计方法的革命。分析设计从过程分析变成了对象获取，从数据结构变成了对象结构。

最后，UML通过称之为业务对象模型（business object model）的视图来说明在达成这些业务目标的过程中涉及到的事物，用逻辑概念来表示它们，并定义它们之间的关系。
业务对象模型则代表了现实世界中的“物”。

UML的诞生：
编程需要的对象不但不能够从设计中自然而然地推导出来，而且强调连续性和过程化的结构化设计与事件驱动型的离散对象结构之间有着难以调和的矛盾。
由于设计无法自然推导出对象结构，使得对象结构到底代表了什么样的含义变得模糊不清；同时，设计如何指导编程，也成为了困扰在人们心中的一大疑问。
随着应用程序的进一步复杂，需求分析成为比设计更为重要的问题。
UML的基本词汇：元模型，语法：表示法或视图（View）。

程序员只负责根据设计结果来编码，
设计师只负责根据需求分析结果来设计，
项目组里还有架构师、质量保证小组等许多角色，各自负担着自己的职责要求，在软件工程的约束下相互协作来完成一个项目。

● 第二章    建模基础

UML通过称之为概念化的过程（Conceptual）来建立适合计算机理解和实现的模型，这个模型称为分析模型（Analysis Model）。
分析模型介于原始需求和计算机实现之间，是一种过渡模型。
分析模型向上映射了原始需求，计算机的可执行代码可以通过分析模型追溯到原始需求；
同时，分析模型向下为计算机实现规定了一种高层次的抽象，这种抽象是一种指导，也是一种约束，计算机实现过程非常容易遵循这种指导和约束来完成可执行代码的设计工作。

绘制分析模型最主要的元模型有：
■ 边界类（boundary）。

从广义上说，任何一件事物都分为里面和外面，外面的事物与里面的事物之间的任何交互都需要有一个边界。比如参与者与系统的交互，系统与系统之间的交互，模块与模块之间的交互等。

■ 实体类（entity）。原始需求中领域模型中的业务实体映射了现实世界中参与者完成业务目标时所涉及的事物，UML采用实体类来重新表达业务实体。

这些实体类可以看作是业务实体的实例化结果。


■ 控制类（control）。边界和实体都是静态的，本身并不会动作。UML采用控制类来表述原始需求中的动态信息，即业务或用例场景中的步骤和活动。

一个道理：只要有人、事、物和规则（定语），就能构成一个有意义的结果，无非是是否合理而已。

【概念模型实例化】
概念模型到设计模型
在设计模型中，概念模型中的边界类可以被转化为操作界面或者系统接口；
控制类可以被转化为计算程序或控制程序，例如工作流、算法体等；
实体类可以转化为数据库表、XML文档或者其他带有持久化特征的类。


转化过程可以遵循的规则：
● 软件架构和框架。软件架构和框架规定了实现类必须实现的接口、必须继承的超类、必须遵守的编程规则等。例如当采用J2EE架构时，Home和Remote接口就是必需的。
● 编程语言。各类编程语言有不同的特点，例如在实现一个界面或者一个可持久化类时，采用C++还是Java作为开发语言会有不同的设计要求。
● 规范或中间件。如果决定采用某个规范或采用某个中间件时，实现类还要遵循规范或中间件规定的那些必需特性。

同样的概念模型会因为选择不同而得到不同的设计模型。
● 技术选型：编程语言，软件规范，中间件


业务模型：
建立模型是人们解决现实世界问题的一种常用手段。
我们通常接触到的建模是为了解决某个问题而建立的一个数学模型，通过数学计算来分析和预测，找出解决问题的办法。
从理论上说，建立模型是指通过对客观事物建立一种抽象的方法，用来表征事物并获得对事物本身的理解，再把这种理解概念化，并将这些逻辑概念组织起来，
形成对所观察的对象的内部结构和工作原理的便于理解的表达。

世界本质无非是由人、事、物和规则组成的。
人是一切的中心，人要做事，做事就会使用一些物并产生另一些物，同时做事需要遵循一定的规则。
人驱动系统，事体现过程，物记录结果，规则是控制。
建立模型的关键就是弄明白有什么人，什么人做什么事，什么事产生什么物，中间有什么规则，再把人、事、物之间的关系定义出来，一个模型也就基本成型了。

【人、事、物、规则就是这样被模型化的。】
第一，UML采用称之为参与者（actor）的元模型作为信息来源提供者，参与者代表了现实世界的“人”。参与者是模型信息来源的提供者，也是第一驱动者。
第二，UML采用称之为用例（use case）的一种元模型来表示驱动者的业务目标，也就是参与者想要做什么并且获得什么。
    这个业务目标就是现实世界中的“事”。而这件事是怎么做的，依据什么规则，则通过称之为业务场景（business scenario）和用例场景（use case scenario）的UML视图来描绘的，这些场景便是现实世界中的“规则”。

UML通过上面的元模型和视图捕获现实世界的人、事、物和规则，
于是现实信息转化成了业务模型，这也是面向对象方法中的第一步。业务模型真实映射了参与者在现实世界的行为，

UML里定义了用例图、对象图、类图、包图、活动图等不同的视图。
这些视图从不同的方面描述了一个软件的结构和组成，所有这些视图的集合表达了一个软件的完整含义。
所以，建模最主要的工作就是为软件绘制那些表达软件含义的视图来完整地表达软件的含义。




第二部分    在学习中思考
● 第三章    UML核心元素

【1】在UML里有一个概念叫版型（stereotype），有些书里也称为类型、构造型。
UML官方文档对参与者的定义为：actor是在系统之外与系统交互的某人或某事物。
参与者可以非人：计算机系统，计时器，传感器，JMS 消息-->即启动者。
找不到启动者说明不是一个功能性需求。

情景：你去 12306 APP 买票，你就是参与者，你通过电话订票，电话的客服是真正的参与者。
【2】业务主角（business actor）是参与者的一个版型，特别用于定义业务的参与者，在需求阶段使用。
【3】处于系统边界内的人，不再是参与者，虽然的确参与了业务的执行过程，它应该被定义为业务工人（business worker）
【4】一组用例实例，每个实例都是系统所执行的一系列操作，这些操作生成特定主角可以观测的值。  用例的构成：参与者、前置条件、场景、后置条件
【5】边界本质上是面向对象方法的一个很重要的概念，与封装的概念师出同源。所以在需求出来之前，我们必须先设想一个边界，这个边界的大小是不确定的，随着需求的明确，边界也逐步变得明朗。
【6】业务实体，业务实体是类（class）的一种版型，特别用于在业务建模阶段建立领域模型。官方文档对业务实体的定义是：业务实体代表业务角色执行业务用例时所处理或使用的“事物”。
首先，业务实体是来自现实世界的，在我们建模的问题领域里一定能够找到与它相对应的事物，并且这个事物是参与者在完成其业务目标的过程中使用到的或创建出来的。
其次，业务实体一定是在分析业务流程的过程当中发现的，而业务流程实际上就是业务用例场景。

首先我们要建立业务用例场景。业务用例场景是参与者实现其业务目标的过程描述，例如我们描述一个寄信人到邮局寄信的用例场景：寄信人到达邮局，购买信封，将信装入信封，写上地址，称重，计算邮资，购买邮票，贴上邮票，邮寄信件，拿走回执。
然后，从业务用例场景中逐个分析动词后面的名词，它们就是业务实体的备选对象。例如邮局、信、信封、地址、邮资、邮票、信件、回执等

【7】包是一种容器，如同文件夹一样，它将某些信息分类，形成逻辑单元。使用包的目的是为了整合复杂的信息，某些语义上相关或者某方面具有共同点的信息都可以分包。
包之间的依赖关系应当是单向的，应当尽量避免双向依赖和循环依赖
【8】分析类说起来也很简单，加起来总共也只有三个，分别边界类（boundary）、控制类（control）和实体类（entity），这些分析类都是类（class）的版型。
【8-1】边界类是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。
对现实世界来说，边界类的实例可以是窗口、通信协议、打印机接口、传感器、终端等，在计算机世界里，边界类也可以是一个消息中间件、一个驱动程序、一组对象接口甚至任意的一个类。
【8-2】定义：控制类用于对一个或几个用例所特有的控制行为进行建模。
在UML的定义中，认为控制类主要起到协调对象的作用，例如从边界类通过控制类访问实体类，或者实体类通过控制类访问另一个实体类。
【8-3】实体类是用于对必须存储的信息和相关行为建模的类。实体对象（实体类的实例）用于保存和更新一些现象的有关信息，例如，事件、人员或者一些现实生活中的对象。
【9】设计类
设计类是系统实施中一个或多个对象的抽象；设计类所对应的对象取决于实施语言。设计类用于设计模型中，它直接使用与编程语言相同的语言来描述。
设计类由类型、属性和方法构成。设计类的名称、属性和方法也直接映射到编码中相应的class、property和method。
【10】关系是非常重要的语义，它抽象出对象之间的联系，让对象构成某个特定的结构
【10-1】关联关系（association），关联关系是一种静态关系，通常与运行状态无关，而是由“常识”、“规则”、“法律”等因素决定的，所以关联关系是一种“强关联”的关系。
【10-2】依赖关系是用一条带箭头的虚线表示的，一个对象在运行期会使用到另一个对象的关系。
【10-3】扩展关系是用一条带箭头的虚线加版型
【10-4】包含关系
● 第四章    UML核心视图
● 第五章    UML核心模型
● 第六章    统一过程核心工作流简介
● 第七章    迭代式软件生命周期



第三部分    在实践中思考
● 第八章    准备工作
● 第九章    获取需求
● 第十章    需求分析
● 第十一章    系统分析
● 第十二章    系统设计
● 第十三章    数据库设计
● 第十四章    开发





第四部分    在提炼中思考
● 第十五章    测试
● 第十六章    理解用例的本质
● 第十七章    理解用例驱动
● 第十八章    用例驱动与领域驱动
● 第十九章    理解建模的抽象层次
● 第二十章    划分子系统的问题
● 第二十一章    学会使用系统边界
● 第二十二章    学会从接口认知事物
● 第二十三章    学会正确选择
● 第二十四章    学会使用设计模式


